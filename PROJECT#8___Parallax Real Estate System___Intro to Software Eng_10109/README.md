[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/cU5K5-bZ)
# csci3509-2024
Skeleton/template code for students of CSCI3509 to develop on.
# Design Rationale
Our report explains the design decisions for the Real Estate Parallax System's implementation, focusing on why certain choices were made to create a maintainable and flexible system. We tried to guide the design with well-established object-oriented principles and design patterns.   The Single Responsibility Principle (SRP) was a key consideration in the design. Each class was designed to have only one responsibility, which makes the system easier to understand and maintain. For instance, the Seller class is dedicated to handling seller-specific tasks, the Property class manages details about properties, and the Bid class focuses on bid-related actions. By this separation of responsibilities, we achieved simplifications on maintenance and debugging, as each class is dedicated to a single responsibility.  The Open/Closed Principle (OCP) was also key in our design. Classes were designed to be extendable without modifying existing code, ensuring that the system remains stable as it evolves. For example, the Payment class can be extended to support new payment methods without changing its core functionality. This principle allows for new features to be added with minimal risk of breaking existing functionality, promoting a more adaptable system.  The Liskov Substitution Principle (LSP) was applied to ensure that subclasses could be used interchangeably with their base classes without causing errors. This principle ensures consistency and reliability across the system. For example, if will have a VIPSeller class in the future, it could replace a Seller object without causing issues, maintaining the expected behavior.  By using the Interface Segregation Principle (ISP), the design avoids forcing classes to implement methods they do not need. Specific boundaries were created for different functionalities, preventing unnecessary dependencies. For example, separate methods for Login and Property ensure that an Admin class does not have to implement methods meant for a Buyer or Seller. This approach reduces unnecessary dependencies and enhances modularity.  The Dependency Inversion Principle (DIP) was followed to ensure that high-level modules do not depend on low-level modules. Instead, both are structured to work through a defined contract or shared set of methods. This was achieved through dependency addition, making the system more flexible and easier to test and maintain. For example, a Seller class does not create a Property class directly but operates with a mechanism that allows the specific implementation to be supplied at runtime. This design choice enhances the system's flexibility, testability, and maintainability.  Several design patterns were also included to solve common problems and improve the system’s design. As an example of implementation, we can show how the observer pattern was applied to allow an object to notify other objects about changes in its state. This is useful in scenarios such as a Seller class notifies Buyer class by using Message class when a requested property is placed or its status changes. By using some design principles and patterns, we also tried to keep the implementation simple meanwhile. As an example, the singleton pattern was not used because the system requires multiple instances of certain classes like Admin, Agent, Property, and others to represent different entities and their specific roles. Using the singleton pattern would have restricted the creation of more than one instance, which is not suitable for this context where each entity needs to maintain its own state and behavior. Instead, we focused on maintaining modularity and clarity in the implementation to ensure scalability and ease of understanding.
The design is focused on extensibility, allowing future requirements to be accommodated with minimal impact on existing code. The compact design ensures that each class and module is self-contained, promoting reusability and ease of maintenance. The use of established design patterns like observer further enhances the system’s ability to adapt to changing requirements without significant refactoring.   The design decisions for the “Parallax Real Estate System” are guided by fundamental object-oriented principles and established design patterns. These decisions ensure that the system is not only functional and efficient but also maintainable and extensible. By focusing on why these principles and patterns are applied, the design rationale provides a solid justification for the architecture of the system, ensuring its longevity and adaptability to future needs.

![Diagram 2024-12-22 09-26-14](https://github.com/user-attachments/assets/b53dfec8-cd05-4a45-8e0d-57712118e011)



